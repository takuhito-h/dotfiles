//------------------------------------------------// File Extensions//------------------------------------------------File.prototype.readInt16 = function() {		var hi = this.readByte();	var lo = this.readByte();	return (hi << 8) + lo;};File.prototype.readInt32 = function() {		var b1 = this.readByte();	var b2 = this.readByte();	var b3 = this.readByte();	var b4 = this.readByte();	return (b1 << 24) + (b2 << 16) + (b3 << 8) + b4;};File.prototype.readByte = function() {		return this.read(1).charCodeAt(0);};File.prototype.readBytes = function(len) {	    for(var i = 0; i < len; i++) {        s += this.readByte();    }	return s;};File.prototype.readString = function(len) {	var result = "";	for(var i = 0; i < len; i++) {        var b = this.readByte();        if(b == 10) {            result += String.fromCharCode(13);  // carriage return            result += String.fromCharCode(10);  // line feed        } else if(32 <= b && b <= 126) {			result += String.fromCharCode(b);		}	}	return result;};// for testfunction ReadTextInfoFromFile(filePath){    var result = {};        var reader = new File(filePath);    reader.encoding = "BINARY";    reader.open("r");    if (reader.read(4) != "8BPS") { // 추가        throw new Exception("fail");    }    var version = reader.readInt16();    reader.seek(20, 1);    var size = reader.readInt32();    reader.seek(size, 1);    size = reader.readInt32();    reader.seek(size, 1);    reader.readBytes(version == 1 ? 4 : 8);    reader.readBytes(version == 1 ? 4 : 8);    var layerCount = reader.readInt16();    layerCount = Math.abs(layerCount);  // 추가    var findFontData = false;    for(var i = 0; i < layerCount; i++)    {        reader.seek(16, 1);        var channelCount = reader.readInt16();        reader.seek(channelCount * (version == 1 ? 6 : 10), 1);        if(reader.read(4) != "8BIM")        {            throw new Exception("fail");        }        reader.readBytes(8);    // 14        var extraLength = reader.readInt32();        var readCount = 0;        size = reader.readInt32();        readCount += 4;        reader.seek(size, 1);        readCount += size;        size = reader.readInt32();        readCount += 4;        reader.seek(size, 1);        readCount += size;        size = reader.readByte();        readCount += 1;        // skip padding        if ((size + 1) % 4 != 0) {            size += (4 - ((size + 1) % 4));        }        reader.seek(size, 1);        readCount += size;                while(readCount < extraLength)        {            var sign = reader.read(4);            readCount += 4;            if (sign != "8BIM" && sign != "8B64") {                throw new Exception("fail");            }            var key = reader.read(4);            readCount += 4;            size = reader.readInt32();            readCount += 4;            if(key != "TySh") // TySh            {                reader.seek(size, 1);                readCount += size;                // skip padding                if(size % 4 > 0)                {                    var padSize = 4 - (size % 4);                    var padding = reader.readBytes(padSize);                    readCount += padSize;                    if(padding[0] != 0x00)                    {                        reader.seek(-padSize, 1);                        readCount -= padSize;                    }                }            }            else            {                reader.seek(56, 1);                readCount += 56;                var fontData = reader.readString(size - 56,);                fontData = fontData.split("StyleRun\r\n")[1].split("RunArray")[1];                                var indexRegex = /\/Font (\d)/g;                var mat = indexRegex.exec(fontData);                var fontIndex = mat[1];                var sizeRegex = /\/FontSize (\d+\.\d+)/g;                mat = sizeRegex.exec(fontData);                result.FontSize = mat[1];                var colorRegex = /\/FillColor\s*<<\s*\/Type\s*\d+\s*\/Values\s*\[\s*(\d*\.\d+) (\d*\.\d+) (\d*\.\d+) (\d*\.\d+)/g;                mat = colorRegex.exec(fontData);                                // ARGB = (0,1,2,3)                result.FontColor = new Color (mat[2] * 255, mat[3] * 255, mat[4] * 255);                                var fontSetRegex = /\/FontSet (\[[^\]]+)/g;                mat = fontSetRegex.exec(fontData);                var fontSet = mat[1];                mat = fontSet.match(/\/Name \([^\)]+\)/g);                var fontNameRegex = /\(([^\)]+)\)/g;                                var fontName = fontNameRegex.exec(mat[fontIndex])[1];                                if(fontName.indexOf ('-') > 0)                {                    fontName = fontName.split ('-');                    result.FontName = fontName[0];                    result.FontStyle =  fontName[1];                    }                else                {                    result.FontName = fontName;                    result.FontStyle = "";                }                                                return result;            }        }    }    reader.close();}